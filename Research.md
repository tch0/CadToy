# CAD程序研究

## 待实现的框架性的功能

- 文件管理实现、文件格式使用json
- 各种坐标变换研究与封装：世界坐标系到屏幕、屏幕到世界、视口裁剪等
- 实体实现，以Line为例
- 坐标拾取器实现（通过屏幕点击或者坐标输入）
- drag过程实现，以Line为例
- 命令行输入解析框架：数据/分支选择等
- 跑通Line命令
- 图形引擎实现，将复杂实体拆分成简单的片元，打包渲染
- 多文档渲染到多个FBO
- Imgui切换到Docking分支，支持将文档拖出
- 常见实体创建命令实现：xline、pline、circle、arc、rect等
- 捕捉实现、使用空间四叉树/R树来实现
- 选择集研究与实现
- 研究几何库、封装几何操作
- 几何编辑框架与相关命令研究与实现
- 命令简写、快捷键等实现，命令框架中引入命令映射表，命令补全

## 功能实现顺序

### 第一阶段：核心架构、数据逻辑分离

- 1、几何数据模型（Database/DOM）：
    - 建立一个 Document 类，持有所有的几何图元（Line, Circle, Arc...）。
    - 关键点：使用双精度浮点数 $double$ 或高精度定点数处理坐标，千万不要用单精度 $float$，否则缩放时会出现严重的精度抖动。
- 2、命令系统（Command Pattern）
    - 每一个修改文档的操作都封装成一个 Command 对象。
    - 实现 UndoStack（撤销栈）。这是 CAD 的命脉，后期补救非常困难
- 3、坐标转换引擎（Transformer）：
    - 实现核心函数：WorldToScreen() 和 ScreenToWorld()。
    - 管理 Camera（持有 Pan 偏移和 Zoom 缩放倍率）

### 第二阶段：渲染管线、画布集成

- 1、FBO视口集成
    - 不要直接在窗口绘图。将几何图形渲染到 OpenGL FBO (Framebuffer Object)，然后通过 ImGui::Image() 显示。
    - 这样你可以轻松实现多文档对比、视口缩放而不干扰 ImGui UI。
- 2、即时绘制（Immediate Layers）：
    - 区分“静态数据渲染”（已保存的线段）和“动态层渲染”（鼠标正在拉出的虚线、捕捉提示）。
    - 利用 ImGui::GetWindowDrawList() 快速实现动态反馈。

### 第三阶段：交互框架、状态机

- 这是 CAD 程序最复杂的部分：非模态交互。
- 1、输入解析器（Tokenizer）：
    - 解析 InputText 传来的字符串（如 L 10,20）
- 2、交互状态机：
    - CAD 处于不同状态：Idle（选择模式）、DrawingLine（等待第一个点）、DrawingLine_Step2（等待第二个点）
    - 输入优先级：当用户按下回车或鼠标点击时，逻辑先发给 ActiveTool。如果 ActiveTool 为空，再发给全局命令解析器。
- 3、坐标捕捉系统（Snapping - 简化版）：
    - 先实现 网格捕捉（Grid Snap）：将鼠标坐标 round 到最近的网格点。这是后续实现复杂对象捕捉（端点、中点）的基础。

### 第四阶段：依次完善功能

- 按照顺序，依次实现

|顺序|	功能模块|	目标|
|:-:|:-:|:-
|1|	视图操作|	鼠标中键平移、滚轮缩放 FBO 内的内容（确保坐标转换无误）。|
|2|	基础解析器|	能够识别 LINE 命令并进入“取点状态”。|
|3|	点输入系统|	支持两种方式取点：鼠标点击、命令行输入 $x,y$ 坐标。|
|4|	图元生成|	执行命令后，真正将 Line 对象加入 Document 并渲染出来。|
|5|	撤销|/重做	确保每画一根线都能被撤销，保证数据一致性。|
|6|	多文档切换|	实现 Tab 或多窗口，验证 Document 类的解耦是否彻底。|
|7|	对象捕捉|	实现端点、交点捕捉，这是从“画图板”进化为“CAD”的标志。|


特别建议：
- 不要在回调里写业务逻辑：InputText 的回调只负责“接收输入”和“清理缓冲区”。真正的绘图逻辑应该由一个 CommandDispatcher 在主循环的 Update 阶段处理。
- 处理 Esc 键：CAD 用户极其依赖 Esc。确保你的状态机能随时响应 Esc 并重置当前所有未完成的命令，同时通过 g_needs_clear 清空输入框。
- 坐标系习惯：OpenGL 默认是Y轴向上，而窗口坐标（ImGui）是Y轴向下。在底层逻辑中，建议统一使用数学笛卡尔坐标系（Y轴向上），仅在最后的渲染阶段进行反转。

## 透明命令

- ZOOM、PAN、GRID 这种不修改几何数据、只改变观察状态的操作，是不应该中断当前正在进行的绘图（如 LINE）或修改（如 MOVE）命令的

三个核心层级的逻辑隔离：
- 为了支持透明操作，主循环输入处理逻辑应该按以下优先级排序：
- 1、系统级/视图级（透明层）
    - 鼠标滚轮/中键：直接修改 Camera 对象的 Zoom 和 Offset
    - 快捷键（如 F7 切换网格）：直接修改全局渲染标志
    - 特点：执行完后，不重置当前命令状态。
- 2、 命令解析层（指令层）
    - InputText 回车：解析字符串。如果是 ZOOM 或 PAN 文本命令，修改 Camera；如果是 LINE，启动状态机。
- 3、当前活动命令层（业务层）
    - 如果当前有一个 ActiveCommand（比如正在画线，已点下第一点），它会“监听”鼠标左键点击。
    - 特点：直到命令完成或按 Esc 才会释放

状态机（State Machine）的设计建议：
- 命令内部采用状态驱动：
- Idle 状态：没有命令执行。命令行输入 LINE -> 实例化 LineTool
- Active 状态：
    - LineTool 内部维护一个子状态（Step 0: 等待起点, Step 1: 等待终点）。
    - 透明性体现：当用户在 Step 1 时滚动鼠标中键，Camera 变了，但 LineTool 依然停留在 Step 1。

CAD框架关键技术点：
- 坐标系解耦：严格区分三种坐标，写好转换函数
    - World Space (世界坐标)：你的几何数据存储位(doudle,doule)
    - Canvas Space (画布/FBO 坐标)：相对于 FBO 左上角的像素坐标。
    - Screen Space (窗口坐标)：ImGui 的全局坐标（用于处理 InputText 和菜单）。
    - world --------Camera------> Canvas -------ImGuiWindowPos-------> Screen
- 渲染分层：
    - 静态层：渲染 Document 中的所有线段。
    - 橡皮筋层 (Rubber Banding)：如果正在画线，实时根据鼠标当前位置画出一根“虚线”到起点。这一步直接在 ImGui::Image() 之后的 ImDrawList 上画，不要去修改 FBO。

